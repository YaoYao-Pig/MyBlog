## lua的泄露问题怎么发现的。
我们的框架是有一些全局运行的system，这个system里的一些数据变化之类的，是需要注册进来的。本来应该在销毁ui的时候反注册，但是我们发现，仓储系统的一个回调消耗的时间随着运行越来越长。然后打断点发现他的回调的表特别特别大
发现一个系统里的一个广播的回调，回调的时间，随着运行时间越来越长，进而发现一个特别大的回调表，发现泄露

并且大家写代码喜欢注册匿名函数：

```lua
-- 错误示范
function Backpack:OnOpen()
    -- 坑就在这里！
    -- 每次执行到这行代码，Lua 都会创建一个【全新的函数实例】(New Function Address)
    GlobalSystem:AddListener(function() 
        self:Refresh()
    end)
end

-- 错误示范 2
function Backpack:OnOpen()
    -- 即使是成员函数，如果没有特殊封装，wrapper 也是新的
    GlobalSystem:AddListener(self.OnRefresh, self) 
end
```

### 如何修复呢？

lua的weaktable做进一步的修复

```lua
local weakTable = {}
setmetatable(weakTable, { __mode = "v" }) -- 设置为弱值表
```

第二个是加一个自动化反注册的函数，跟随生命周期自动注册自动释放。（这是我们的解决方法）