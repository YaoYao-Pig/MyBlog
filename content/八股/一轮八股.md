# C++

## 编译

### 编译流程

预处理 编译，汇编，连接

预处理就是宏展开，头文件完全拷贝进去

### 动态和静态链接

关键字：重定位，重定位，符号表

------

静态链接：

静态链接发生在编译时，动态链接发生在加载时

链接很重要的一点就是重定位

> **链接（Linking）是过程，符号表（Symbol Table）是数据依据，重定位（Relocation）是最终手段**

编译是基于一个编译单元进行的，一个编译单元一次编译行为产出一个目标文件.obj，这时候，如果一个函数是在另一个编译单元定义的，就只能暂时做个记号，这个记号就存在符号表里

| **符号名** | **类型** | **状态**         | **偏移量 (Offset)**         |
| ---------- | -------- | ---------------- | --------------------------- |
| `main`     | 函数     | **已定义**       | `0x0000` (在当前文件的开头) |
| `count`    | 变量     | **已定义**       | `0x0004`                    |
| `printf`   | 函数     | **未定义 (UND)** | `?` (等链接器处理)          |

#### 重定位的过程：

1. **合并：** 链接器把所有输入文件的代码段 (`.text`) 和数据段 (`.data`) 合并。
2. **计算地址：** 链接器决定最终的内存布局。假设 `printf` 最终被安放在 `0x0804`。
3. **打补丁 (Patching)：** 链接器根据**重定位表**的指引，找到那个暂时填了 `0x0000` 的坑，把它修改为真实的地址 `0x0804`。

------

动态链接：

因为动态链接库被不同的程序加载的位置可能不同，因此动态链接库在编译时生成的指令不能包含相对地址，也就是地址无关代码PIC

两个关键数据结构：GOT 和 PLT的出现，是为了让代码段（Code Segment，只读、可共享）**保持不变，而将变化的地址放在**数据段（Data Segment，可读写、每个进程私有）

#### (1) GOT (Global Offset Table) —— 全局偏移表

- **本质：** 一个数组，存放着绝对虚拟地址。
- **位置：** 数据段（`.data`）。
- **作用：** 代码想要访问外部变量或函数时，不直接访问，而是去查 GOT。GOT 里存的才是真正的地址。
- **关键点：**
  - 1.  因为 GOT 在数据段，每个进程都有自己的一份 GOT。加载器只需要修改 GOT 里的值，而不需要修改代码段的指令。
  - 2. **GOT 是相对于“使用库的程序”（调用方）来说的。** 更准确地说：**每一个编译单元（Executable 或 Shared Library），只要它引用了外部符号，它就必须维护一份属于自己的 GOT。**
    3. 

#### (2) PLT (Procedure Linkage Table) —— 过程链接表

- **本质：** 一小段跳板代码（Trampoline）。
- **位置：** 代码段（`.text`）。
- **作用：** 它是外部函数的“代理人”。当你的程序调用 `printf` 时，实际上是调用了 `printf@plt`。

现代动态链接器非常懒。程序启动时，它不会把成千上万个函数的地址都解析出来（那太慢了）。它采用了**延迟绑定**策略：**只有当你第一次调用某个函数时，链接器才去解析它的地址。**

> 让我们看看当你调用 `printf` 时，底层发生了什么：
>
> #### 阶段一：编译完成时
>
> - **代码中：** 调用指令指向 `printf@plt`。
> - **GOT中：** `printf` 对应的条目填的不是真实地址，而是**指回 PLT 的下一条指令**（这就像写着“我不知道，你问上面吧”）。
>
> #### 阶段二：第一次调用 `printf`
>
> 1. **代码跳转：** `call printf@plt`。
> 2. **PLT 跳转：** PLT 第一条指令是 `jmp *GOT[printf]`。
> 3. **回马枪：** 因为是第一次，GOT 里存的是 PLT 的下一行代码。所以指令并没有跳去真正的 printf，而是跳回了 PLT 的下一行。
> 4. **召唤链接器：** PLT 接着做两件事：
>    - 把 `printf` 的 ID 压栈。
>    - 调用动态链接器（Runtime Linker, `ld-linux.so`）的解析函数 `_dl_runtime_resolve`。
> 5. **解析地址：** 动态链接器去查找 `libc.so` 的符号表，找到了 `printf` 的真实内存地址（比如 `0xDEADBEEF`）。
> 6. **填表：** 链接器把这个真实地址 `0xDEADBEEF` 填入 **GOT** 中。
> 7. **执行：** 链接器跳转到 `0xDEADBEEF` 执行真正的 `printf`。
>
> #### 阶段三：第二次调用 `printf`
>
> 1. **代码跳转：** `call printf@plt`。
>
> 2. **PLT 跳转：** `jmp *GOT[printf]`。
>
> 3. **直达目标：** 这一次，GOT 里已经是真实的 `0xDEADBEEF` 了。程序直接飞到 `printf` 函数体执行。
>
>    **Code:** `call PLT[printf]` ↓ **PLT[printf]:** `jmp *GOT[printf]` │ ├─── **(第一次)** ──→ 查 GOT 发现是“自己下一行” → `push ID` → `Call Linker` → **修改 GOT** → `Run Function`│└─── **(第二次)** ──→ 查 GOT 发现是“真实地址” ────→ `Run Function`

------

注意：

1. **动态链接的 GOT 表项：** 存的是**绝对地址**。

   **静态链接的指令码：** 存的大多是**相对偏移**。

   为什么呢：因为静态链接的代码段是连续的，但是动态链接的代码段是不连续的

2. 动态链接的时候，是如何找到函数的绝对虚拟地址的呢？

   链接器维护了一个非常重要的数据结构，叫 **`link_map`**。这是一个**双向链表**，记录了当前进程加载的所有模块（包括主程序自己和所有依赖库）。

   链表大概长这样： `[Game.exe] <-> [libstdc++.so] <-> [libc.so] <-> [kernel32.dll] ...`

   每个节点里都记录了关键信息：

   - **名字**：比如 `libc.so`
   - **基址 (Base Address)**：比如 `0x7ffff7a00000` (这是操作系统加载时随机分配的)
   - **符号表位置**：指向该库内部 `.dynsym` 的指针。

   > 1. 链接器计算 "printf" 的哈希值。
   > 2. 在 `libc.so` 的哈希表里快速定位。
   > 3. 定位到符号表中的具体条目。
   > 4. 读取该条目，发现：**`printf` 在本文件内部的偏移量 (Offset) 是 `0x500`。**
   >
   > 现在所有拼图都齐了：
   >
   > 1. **基址 (Base)：** 在第二步遍历 `link_map` 时，链接器知道 `libc.so` 被加载到了 `0x7ffff7a00000`。
   > 2. **偏移 (Offset)：** 在第三步查符号表时，知道 `printf` 在库内的位置是 `0x500`。

   也就是说，链接器知道每一个动态链接库的基址，也可以通过动态链接库的符号表知道一个具体函数的Offset，用基址+Offset就可以得到绝对虚拟地址

3. 主程序知道连接方式，也分知晓和不知晓：

   > 在构建程序的过程中，**编译器（Compiler）**和**链接器（Linker）**确实会根据“目标函数是静态库里的还是动态库里的”，生成完全不同的指令代码。
   >
   > 为了讲清楚这个“区别对待”的过程，我们需要把视角分为 **Windows (MSVC)** 和 **Linux (GCC/Clang)** 两种流派，因为它们的处理策略完全不同。
   >
   > ------
   >
   > ### 1. Windows 的做法：显式告知 (Explicit)
   >
   > 在 Windows 开发中（C++/DX12），你应该经常见到 `__declspec(dllimport)` 这个宏。这玩意儿就是用来**提前告诉编译器**：“嘿，这个函数是动态链接的！”
   >
   > #### 场景 A：编译器不知道是动态链接 (没有写 `dllimport`)
   >
   > 如果你只写了 void foo();，编译器默认以为它是静态链接（或者同一个模块里的函数）。
   >
   > 编译器生成的指令是普通的相对跳转：
   >
   > Code snippet
   >
   > ```
   > call foo  ; 编译器以为 foo 就在附近
   > ```
   >
   > 到了链接阶段，链接器发现 foo 其实在 DLL 里。怎么办？编译器生成的指令已经是 call 相对地址 了，改不了了。
   >
   > 补救措施： 链接器被迫在你的代码里偷偷插入一段小代码（Thunk/Stub），看起来像这样：
   >
   > Code snippet
   >
   > ```
   > ; 这一段是链接器自动生成的桩代码
   > foo_stub:
   >     jmp *__imp_foo  ; 跳去查导入表 (IAT)
   > ```
   >
   > 然后把原本的 call foo 修改为 call foo_stub。
   >
   > 代价： 多了一次跳转（Call -> Stub -> DLL）。
   >
   > #### 场景 B：编译器知道是动态链接 (写了 `dllimport`)
   >
   > 如果你写了 __declspec(dllimport) void foo();。
   >
   > 编译器一看：“哦，这是别人的函数。”
   >
   > 它会直接生成最高效的间接调用指令，跳过中间商：
   >
   > Code snippet
   >
   > ```
   > call *__imp_foo  ; 直接去读导入表里的地址并跳转
   > ```
   >
   > **结果：** 省略了中间那个 Stub，性能更高。
   >
   > ------
   >
   > ### 2. Linux 的做法：统一代理 (Implicit)
   >
   > Linux (ELF) 的哲学不一样。它默认假设**你不知道**这个函数在哪（可能是静态，可能是动态）。
   >
   > #### 编译器策略：全都推给 PLT
   >
   > GCC 在编译 main.c 时，看到 printf，它根本不管 printf 是静态还是动态。
   >
   > 它一律生成指向 PLT 的代码：
   >
   > Code snippet
   >
   > ```
   > call printf@plt
   > ```
   >
   > #### 链接器策略：最后裁决
   >
   > 到了链接阶段 (`ld`)，链接器看着你给它的库文件，决定怎么填这个坑：
   >
   > 1. **如果你给的是静态库 (`libc.a`)：**
   >    - 链接器把 `printf` 的二进制代码**抄**到你的可执行文件里。
   >    - 链接器会把那行 `call printf@plt` **修改**（重写）为直接调用 `call printf_body`（不再走 PLT/GOT 那一套，或者虽然保留符号，但指向本地代码）。
   >    - *注：现代链接器优化可能会直接消除 PLT 引用。*
   > 2. **如果你给的是动态库 (`libc.so`)：**
   >    - 链接器生成真正的 **PLT 表** 和 **GOT 表**。
   >    - 保留 `call printf@plt` 不变。
   >    - 建立对 `libc.so` 的动态依赖信息。
   >
   > ------
   >
   > ### 3. 核心差异总结：代码长什么样？
   >
   > 主程序（调用者）根据“知不知道是动态链接”，最终生成的汇编指令会有本质区别。
   >
   > 我们用伪代码对比一下 **调用 `foo()`** 的三种最终形态：
   >
   > | **情景**                               | **主程序生成的指令**   | **机制**         | **备注**                                                |
   > | -------------------------------------- | ---------------------- | ---------------- | ------------------------------------------------------- |
   > | **静态链接**                           | `call 0x1000`          | **直接相对跳转** | 最快。地址是写死的相对偏移。                            |
   > | **动态链接 (Windows `dllimport`)**     | `call *[0x5000]`       | **间接内存跳转** | 也是最快（针对动态）。直接去读 IAT 表里的绝对地址跳走。 |
   > | **动态链接 (Linux 默认 / Win 无声明)** | `call 0x2000` (去 PLT) | **跳板模式**     | 稍慢。先跳到 PLT (0x2000)，PLT 再查表跳走。             |
   >
   > ### 你的结论
   >
   > **是的，你的理解完全正确。**
   >
   > - **编译期知晓：** 如果通过关键字（如 `dllimport`）让编译器提前知道了，编译器就能生成**直接查表**的代码（`call *ADDR`），省去中间跳转。
   > - **链接期知晓：** 即使编译器不知道，链接器在最后时刻看到了库文件（`.a` vs `.so`），它会决定是**拷贝代码**（静态）还是**生成 PLT/GOT 条目**（动态）。
   >
   > 这就是为什么在 C/C++ 头文件中，经常看到这种宏定义：
   >
   > C++
   >
   > ```
   > #ifdef MY_LIB_EXPORT
   >   #define API __declspec(dllexport) // 编译 DLL 时：我是导出者
   > #else
   >   #define API __declspec(dllimport) // 编译主程序时：我是导入者（编译器：懂了，我给你生成优化的间接调用代码）
   > #endif
   > 
   > API void MyFunction();
   > ```
   >
   > 这个宏的存在，就是为了让主程序在编译时**“知道”**这是一个动态链接函数，从而选择最优的链接方式。

## 基础语法

### 四种cast和bit_cast

### 类型转换（CStyle和C++Style）

### 基本类型大小

### 整数存储方式，Float存储方式



## 类和对象

### 构造函数和析构函数能否抛出异常

### 普通函数指针，函数对象以及成员函数指针

### 空类Class大小





## 运行

### 运行时 函数调用栈帧移动方式



## 内存管理

### Malloc原理，内存池管理，

### Malloc/free，new/delete的区别

## delete和delete[]的区别，以及为什么会有这种区别

### 内存对齐以及计算方式，为什么要有内存对齐



## 数据结构与算法以及STL

### 红黑树底层，延伸到STL的Map和哈希表

### std::sort是如何优化的

### vector是如何扩容的

### deque是如何管理空间，如何实现O1的插入队首和队尾的，以及作为Adapte的Stack和Queue

### C++和C对于字符串的优化实现，以及C++ stl：string的实现

### 迭代器分类

### hash冲突如何解决

### 跳表







## 智能指针

### 实现Shared_ptr

### Weak_ptr的原理和作用

### 不使用weakptr的情况下解决shared_ptr的循环引用

### Unique_ptr



## 多态

### 动态多态的原理

### 虚函数表和虚函数的存储位置

### 多继承下类的内存结构

### 菱形继承下的 类的内存结构

### 虚基类的实现原理和内存结构

### 虚基类+虚函数的内存结构

### dynamic_cast的实现原理



## 元编程（泛型）

### 泛型的实现原理

### template为什么定义和实现都要在头文件

### 什么是类型擦除

### 类型萃取 + 迭代器实现

### 什么是偏特化

### 右值引用和万能引用

### std:move和std::forward的实现以及原理

### 模板函数可以是虚函数吗





## 其他

### inline的原理和作用

### volatile和atomic

### constexpr和Const

### 顶层底层Const

### lambda表达式的原理

### 函数对象是什么，如何实现的函数对象的效果以及std:functional

### Name Mangling



## 现代C++

### 有什么C++17/20 的新特性吗

### 

# Unity

## Unity基础

### 协程的原理

### 协程的GC

### Unity生命周期函数

### Unity的相机渲染以及多相机渲染（如何排序，如何筛选）

### Unity相机的剔除

### 如何判断一个对象是否在屏幕内

### 如何判断一个点是否在三角形内部

### 如何判断射线和包围盒相交

### 如何判断两个包围盒相交

### 如何判断两个三角形相交

### FixedUpdate 的原理

### Unity的OverDrall问题

### Unity如何引入C++代码

### 欧拉角和万向锁

### GPUInstacing

### AB包和资源管理，Unity是如何找到资源的



## UGUI

### UGUI绘制流程，包括如何材质和布局

### UGUI布局更新逻辑，如何递归的获取子节点以及如何反递归的设置各层的大小

### Pivot，Anchor和RectTransform

### 屏幕坐标系和UI局部坐标系的异同

### Canvas的分类，每一类都是如何对应的

### UGUI的合批，断批的条件

### UGUI和Rebuild和ReBatch的异同



## Built-in和URP

### Built-in的动态静态合批

### SRP的优化重点和Built-in的区别

### **SRP Batcher**





## 设计模式

### MVC，MVVM结合项目

### ECS 结合实习

### 单例模式





## 寻路

### Unity的NavMesh的原理

### AStar的实现

### DFS，迪杰斯特拉



## AI

### 状态机和分层状态机

### 行为树



## 动画

### 混合树

### Avatar和遮罩

### Animator和Animation的区别



## 其他

### 贝母GC

# 图形学

## 渲染

### 渲染流程

### EarlyZ

### 为什么AlphaTest或者说是Discard会打断EarlyZ

### 前向渲染和延迟渲染



### 不透明物体的渲染顺序应该是怎样的

### 透明渲染

### 顺序无关的透明效果



## 阴影

### 硬阴影

### ShadowMap，以及ShadowMap的Bias如何解决毛刺，以及MipMap

### CSM



## 反走样和摩尔纹

### MipMap

### MSAA，TSAA，SSAA

### 各向异性



## 高级图形学

### AO和SSAO

### PBR的BRDF公式

### PBR的基本原理

### IBL的实现是如何的

### 如何实现SkyBox



## 其他

### 各种剔除的方法（区分CPU时候的剔除和GPU时候的剔除），视锥剔除和裁剪

### AABB和OBB

### 八叉树，KDTree，BVH

### Gamma矫正，线性空间





### LOD

### 欧拉角和欧拉角

### 凹凸贴图，法线贴图等



## DX12

### DX12的创建渲染流程



# Lua

## Lua基础

### Lua的String实现和问题

### Lua的类型

### Lua实现面向对象



## LuaGC

### 渐进式GC的状态机流程

### 三色标记法和渐进式GC

### 渐进式GC的各个阶段的作用

### 写入屏障

### 分代GC



## XLua

### XLua如何和C#交互

### XLua下C#的Struct和Class的区别（值类型和引用类型在传递的区别）

### XLua的虚拟机在哪个分区？



# OS

## 进程和线程

## 分页和分段

## 进程间通信

## SysCall

### 原子，信号量

### 生产者消费者问题

### 虚拟内存的原理和实现方法

### 内存轮转，FIFO，LFO等



# 场景

## 战争迷雾优化顶点树

