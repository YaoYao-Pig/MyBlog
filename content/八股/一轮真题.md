## C#String是什么类型，它的底层是什么

是一个不变的引用类型

这个string字面量是有驻留池内化的

```c#
string a = "Hello";
string b = "Hello";
Console.WriteLine(ReferenceEquals(a, b)); // 输出 True

//程序启动时，CLR 发现字面量 "Hello"。
//它在堆上创建 "Hello" 对象，并将其引用存入驻留池。
//当创建变量 b 时，CLR 发现池里已经有 "Hello" 了，直接返回同一个内存地址，而不是创建新对象。 注意：这通常只针对编译期确定的“字面量”。动态计算出来的字符串（如 i.ToString()）默认不进池。
```

StringBuilder的底层是一个Char数组 + 链表：

```c#
public sealed class StringBuilder
{
    // 当前这一块（Chunk）存储字符的数组
    internal char[] m_ChunkChars; 
    
    // 指向“前一块” StringBuilder 的引用（这就构成了链表！）
    internal StringBuilder m_ChunkPrevious; 
    
    // 当前这一块数组里已经用了多少长度
    internal int m_ChunkLength;
    
    // ... 其他字段如 MaxCapacity 等
}
```

`StringBuilder` 在内存中并不是连续的一大长条，而是一节一节的（术语叫 **Rope String** 结构）。

- 当你创建一个 `new StringBuilder()` 时，它分配一个小数组（比如 16 个字符）。
- 当你 `Append` 时，它往这个数组里填数据。
- **关键点来了：** 当这个数组**填满**了，它**不会**像 `List<T>` 那样去申请一个双倍大的新数组然后把旧数据拷贝过去。
- **相反**，它会创建一个**新的 StringBuilder 节点**（带有一个新的 char 数组），然后让新节点的 `m_ChunkPrevious` 指向旧的节点。

假设你不断 Append，内存里实际上是这样增长的：

**阶段 1：** `[ SB1: "Hello" ]`

**阶段 2：** (Append " World", 假设 SB1 满了) `[ SB2: " World" ]` --> 指向 --> `[ SB1: "Hello" ]`

**阶段 3：** (Append " From C#", 假设 SB2 满了) `[ SB3: " From C#" ]` --> 指向 --> `[ SB2: " World" ]` --> 指向 --> `[ SB1: "Hello" ]`

这就是它高效的核心原因：**扩容时，它不需要拷贝旧数据！** 它只需要挂载一个新的“车厢”在后面即可。



## 有障碍物的寻路逻辑如何处理？

###  网格法

比如AStar的时候，每个格子标记它是不是障碍，如果是，那么OpenList查找邻居节点的时候，遇到是障碍的直接跳过

### NaveMesh

**逻辑：** 不切格子，而是把“可以走的地方”铺成一个个多边形（通常是三角形）。障碍物所在的地方则是“空洞”。

**处理障碍：** 寻路变成了在这些多边形之间找连线。因为障碍物位置本身就没有网格，算法根本不会考虑去走那里。

**优势：** 比网格法省内存，能贴合复杂的 3D 地形。

### 如何动态避障

#### A. 动态挖孔 (NavMesh Carving)

https://www.youtube.com/watch?v=PxudQmMTLkg

这是 Unity `NavMeshObstacle` 组件的原理。

- **逻辑：** 当一个物体停止移动时，它会在当前的 NavMesh 上“切”出一个洞，强制 NavMesh 重新构建局部网格。
- **底层：** 这是一个昂贵的操作（涉及多边形布尔运算），所以通常只用于**大件的、偶尔移动的**物体（如关上的门、倒下的树）。

#### B. 局部避障 (Local Avoidance / RVO)

如果障碍物是**另一个正在移动的单位**（比如两个小兵相向而行），这时候不改路，而是互相“挤”过去。

- **算法：** 最常用的是 **RVO (Reciprocal Velocity Obstacles)** 或 **ORCA**。
- **原理：**
  1. 每个单位都有一个速度向量。
  2. 算法预测未来几帧如果保持当前速度，是否会相撞。
  3. 如果会撞，就计算一个“对双方都最小改动”的新速度向量（比如稍微向右偏一点）。
- **结果：** 单位看起来像是长了眼睛一样自然地绕开了对方，而不需要重新计算 A* 路径。

### C.网格法

还是，设置为障碍物





## 如果哈希表有超大量冲突（比如一百万的冲突），怎么办

1. Hash冲突的时候，不是有个拉链法吗，如果冲突超级多，那就直接把那个拉链的链表转换成红黑树
2. 直接换红黑树，LogN的平均查找复杂度，最坏也是LogN
3. 重新设计hash函数
4. 调整哈希表容量然后ReHash



## Vector或者CSharp List这种连续存储的容器，如果有百万个元素如何优化性能？

1. 提前分配大小，不要老是扩容搬迁

   1. **C++:** 使用 `vector.reserve(1000000)`。

      **C#:** 使用构造函数 `new List<T>(1000000)` 或设置 `list.Capacity = 1000000`

2. 实现右值的语义，让它别拷贝

3. 用emplaceback替代push_back

4. 对于C#来说，这时候尽量用List<Struct> 而不是List<Class> 

5. 对于C#来说，千万不要用List<object>或者ArrayList存储值类型，避免Boxing/unBoxing（接口也不行，也会Boxing）

## Vector或者CSharp List这种连续存储的容器，如果要删除其中一部分元素怎么处理？

Vector：最常用的是 **Erase-Remove** 法

```c++
// C++11 :1. remove_if 把不需要删除的元素移到前面，返回“新逻辑结尾”的迭代器
auto new_end = std::remove_if(v.begin(), v.end(), [](int x) {
    return x % 2 == 0;
});
// 2. erase 真正物理删除尾部的废弃数据
v.erase(new_end, v.end());

// C++20
std::vector<int> v = {1, 2, 3, 4, 5, 6};
// 一行代码，O(N) 复杂度，无内存泄漏
std::erase_if(v, [](int x) { 
    return x % 2 == 0; // 删除所有偶数
});
```

List:

```c#
List<int> list = new List<int> { 1, 2, 3, 4, 5, 6 };

// 内部实现高度优化，直接操作底层数组，不产生额外数组分配
// 复杂度：O(N)
list.RemoveAll(x => x % 2 == 0);
```

Unity:

```c#
List<GameObject> objs = ...;
// 假设我们要删除某些特定的对象
for (int i = objs.Count - 1; i >= 0; i--) {
    if (ShouldDelete(objs[i])) {
        // 1. 将当前要删的元素，被“末尾元素”覆盖
        //    (不需要真正的 Swap，覆盖即可，因为末尾的马上就要丢弃了)
        int lastIndex = objs.Count - 1;
        if (i < lastIndex) {
            objs[i] = objs[lastIndex]; 
        }
        
        // 2. 移除末尾 O(1)
        objs.RemoveAt(lastIndex);
    }
}
```



## 自动化打包的时候，如果不同于资源用到了同样的材质，如何自动化处理？

如果不处理，Unity 的默认行为是：**“谁用了我，我就进谁的包”**。 如果 `Prefab A`（在 Bundle A）和 `Prefab B`（在 Bundle B）都引用了 `Material M`，而 `Material M` 没有被显式指定 Bundle，那么 **`Material M` 会被复制两份**，分别打进 Bundle A 和 Bundle B。这会导致包体膨胀和运行时内存中有两份一模一样的材质（无法合批）。

要根据引用计数先判断：

我们需要写一个编辑器脚本，在打包前运行。逻辑如下：

1. **收集目标：** 找到所有你明确要打包的主资源（比如所有的 Prefab）。
2. **分析依赖：** 对每一个主资源，使用 `AssetDatabase.GetDependencies` 获取它所有的依赖链（材质、贴图、Shader）。
3. **计算引用：** 统计每一个依赖资源被多少个不同的 Bundle 引用了。
4. **自动分包：**
   - 如果引用计数 **= 1**：它属于私有依赖，不需要处理，直接跟着主资源进包。
   - 如果引用计数 **>= 2**：它是**共享资源**。必须把它的 `AssetBundleName` 单独设置（例如 `shared/materials.bundle`），或者根据文件夹结构自动命名。



分析出来是共享资源后，需要一个分包策略：一般有三种：零散法（也就是每个共享资源都有一个单独的包），巨型公共包（也就是共享资源根据类型都塞入一个大包）

还有我们用的方法：基于文件夹/模块的聚合 (Directory Based) 

例如：编写规则，如果发现材质在 `Assets/Art/Chapter1/Materials` 下且被共享，就打入 `chapter1_shared.bundle`

下面是个例子：核心的思路是：

首先从主要资源（一般是预制体，场景，配置文件还有音频等大图）出发作为查找的Root，找到根所有依赖的资源，并且给这些资源记录一个引用计数（也就是下面的assetRefMap）

记录完了之后，遍历所有的共享资源assetRefMap，如果引用计数大于1，那么说明它不知被一个主资源引用，那么应该打入共享包，如果等于1，说明它只被一个主资源依赖。那么它就直接跟着主资源进入主包就行了。

共享包的打包思路是：根据共享资源所在文件夹的名字来分包。

```c#
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Linq;

public class AutoDependencyPacker
{
    //主资源入口
    private static string[] RootsToScan = new string[] 
    { 
        "Assets/Resources/Prefabs", 
    };

    [MenuItem("Tools/AssetBundle/Auto Pack Shared Assets (Directory Based)")]
    public static void Run()
    {
        // 清除所有未使用的 Bundle Name，避免历史数据干扰
        AssetDatabase.RemoveUnusedAssetBundleNames();
        
        // 数据结构：记录 [依赖资源路径 -> 引用它的主Bundle列表]
        Dictionary<string, HashSet<string>> assetRefMap = new Dictionary<string, HashSet<string>>();

        // 先给主资源打上包名，并收集它们的依赖
        // 这里假设主资源的包名逻辑是：根据文件夹或者文件名设定
        List<string> mainAssets = new List<string>();
        foreach (var root in RootsToScan)
        {
            if(!Directory.Exists(root)) continue;
            
            string[] guids = AssetDatabase.FindAssets("", new[] { root });
            foreach (var guid in guids)
            {
                string path = AssetDatabase.GUIDToAssetPath(guid);
                if (IsDirectory(path)) continue; // 忽略文件夹本身

                // 给主资源设置包名
                string dictStr = Path.GetDirectoryName(path);
                AssetImporter importer = AssetImporter.GetAtPath(path);
                
                string mainBundleName = "main_" + Path.GetFileNameWithoutExtension(dictStr).ToLower();
                importer.assetBundleName = mainBundleName;

                mainAssets.Add(path);
            }
        }

        // 遍历主资源，构建依赖图
        int progress = 0;
        foreach (var mainAssetPath in mainAssets)
        {
            EditorUtility.DisplayProgressBar("Analyzing Dependencies", mainAssetPath, (float)progress++ / mainAssets.Count);

            // 获取该资源所属的主包名
            string mainBundleName = AssetImporter.GetAtPath(mainAssetPath).assetBundleName;

            // 递归获取所有依赖的Asset
            string[] dependencies = AssetDatabase.GetDependencies(mainAssetPath, true);
            foreach (var depPath in dependencies)
            {
                Debug.Log(depPath);
            }

            foreach (var depPath in dependencies)
            {
                if (ValidateDependency(depPath, mainAssetPath)) //排除自己，脚本，内置资源等
                {
                    if (!assetRefMap.ContainsKey(depPath))
                        assetRefMap[depPath] = new HashSet<string>();

                    // 记录depPath 被 mainBundleName 引用了
                    assetRefMap[depPath].Add(mainBundleName);
                }
            }
        }

        // 找出共享资源
        int sharedCount = 0;
        foreach (var kvp in assetRefMap)
        {
            string assetPath = kvp.Key;
            HashSet<string> parentBundles = kvp.Value;

            //>= 2 个不同的主包引用，就是共享资源
            if (parentBundles.Count > 1)
            {
                SetBundleNameByDirectory(assetPath);
                sharedCount++;
            }
            else
            {
                // 只被 1 个包引用，打进主包
                AssetImporter importer = AssetImporter.GetAtPath(assetPath);
                // 只有当它不是我们显式指定的主资源时，才清除
                if (!IsMainAsset(assetPath)) 
                {
                    importer.assetBundleName = ""; 
                }
            }
        }

        EditorUtility.ClearProgressBar();
        AssetDatabase.RemoveUnusedAssetBundleNames();
        AssetDatabase.Refresh();
        
        Debug.Log($"打包分析完成！共处理共享资源：{sharedCount} 个");
    }
    
    private static void SetBundleNameByDirectory(string assetPath)
    {
        // 获取该资源所在的文件夹路径
        // 输入: Assets/Art/Environment/Rocks/Rock01.mat
        // 目录: Assets/Art/Environment/Rocks
        string directory = Path.GetDirectoryName(assetPath);
        
        string bundleName = "shared_" + directory.Replace("/", "_").Replace("\\", "_").Replace(" ", "").ToLower();

        AssetImporter importer = AssetImporter.GetAtPath(assetPath);
        importer.assetBundleName = bundleName;
    }
    private static bool ValidateDependency(string depPath, string mainAssetPath)
    {
        // 排除自己
        if (depPath == mainAssetPath) return false;
        // 排除脚本
        if (depPath.EndsWith(".cs") || depPath.EndsWith(".js")) return false;
        // 排除 Editor 资源
        if (depPath.Contains("/Editor/")) return false;
        // 排除内置资源 (Resources/unity_builtin_extra)
        if (!depPath.StartsWith("Assets/")) return false;

        return true;
    }

    private static bool IsDirectory(string path)
    {
        return Directory.Exists(path);
    }
    
    private static bool IsMainAsset(string path)
    {
        // 这里简单判定：如果在我们的扫描根目录下，就是主资源
        foreach (var root in RootsToScan)
        {
            if (path.StartsWith(root)) return true;
        }
        return false;
    }
}
```



## 为啥需要自动化打包

一个是方便管理，第二个是有很多隐性的资源是很难管理的，如果不用这种方式，比如Mesh

在 Project 窗口里看到的 `Hero.fbx`，其实是一个**容器（Container Asset）**。

当你把这个 FBX 拖进场景时，Unity 实际上引用的是这个容器里的**子对象**。 一个典型的 `Hero.fbx` 在导入 Unity 后，内存结构是这样的：

- **Asset (Hero.fbx)** <-- 这是文件，有唯一的 GUID

  - `GameObject` (根节点)
  - `Transform`
  - **`Mesh` (网格数据：顶点、UV、法线)** <-- **这才是被 Prefab 引用的真身！**
  - `AnimationClip` (如果有动画)
  - `Avatar` (骨骼映射)

  当你此时有两个预制体：

  - `Prefab_A` 里的 `MeshFilter` 引用了 `Hero` 的网格。
  - `Prefab_B` 里的 `MeshFilter` 也引用了 `Hero` 的网格。

  在自动化打包脚本的眼中，情况是这样的：

  1. **扫描 Prefab_A** -> 发现依赖 -> `Assets/Models/Hero.fbx`
  2. **扫描 Prefab_B** -> 发现依赖 -> `Assets/Models/Hero.fbx`

  **判定结果：** `Hero.fbx` 被两个不同的包引用了。 **结论：** `Hero.fbx` 是**共享资源**。

如果你之前的自动化脚本没有处理 `.fbx` 后缀的文件，或者没有处理 Mesh 类型：

- **Bundle A (含 Prefab A)**：里面会偷偷塞进一份 `Hero` 的网格数据（比如 5MB）。
- **Bundle B (含 Prefab B)**：里面也会偷偷塞进一份 `Hero` 的网格数据（又一个 5MB）。
- **后果**：
  1. 包体变大 5MB。
  2. 如果 AB 两个包同时加载，内存里会有两份一模一样的网格，**不能合批（Batching）**，因为内存地址不同，GPU 认为是两个不同的东西。



## Shader变体的自动化打包



## 自己实现的渲染引擎中，如何处理RayPicking问题（如何把鼠标在屏幕上的点击映射到3维的模型上）

一般就是：几何法

核心思路：逆向管线 (Reverse Pipeline)

渲染是把 3D 坐标变成 2D 屏幕像素。拾取则是把 2D 屏幕像素变成 3D 射线。

需要做的是：**屏幕空间 (Screen) $\rightarrow$ NDC (标准设备坐标) $\rightarrow$ 观察空间 (View) $\rightarrow$ 世界空间 (World)**。

### 第一步：生成射线 (Ray Generation)

假设鼠标在屏幕上的坐标是 $(x, y)$，屏幕宽为 $W$，高为 $H$。

#### 1. 屏幕坐标转 NDC

屏幕坐标通常原点在左上角 (0, 0)，X 向右，Y 向下。

NDC 坐标原点在中心 (0, 0)，X 范围 $[-1, 1]$，Y 范围 $[-1, 1]$（Y 轴通常向上）。
$$
x_{ndc} = \left( \frac{2x}{W} \right) - 1 \\
y_{ndc} = 1 - \left( \frac{2y}{H} \right) \quad (\text{注意 Y 轴翻转})
$$

#### 2. NDC 转 世界空间 (Unproject)

我们要找射线上的两个点，或者一个起点和一个方向。

在 NDC 中，近裁剪面（Near Plane）是 $z=0$ (DX) 或 $z=-1$ (GL)，远裁剪面是 $z=1$。

我们可以定义射线在 NDC 中的一个点（比如近平面上的点）：
$$
P_{ndc} = (x_{ndc}, y_{ndc}, 0, 1) (注意：齐次坐标 w=1)
$$
要转回世界空间，我们需要 View-Projection 矩阵的逆矩阵：
$$
M_{inv} = (M_{proj} \times M_{view})^{-1} \\
P_{world\_temp} = M_{inv} \times P_{ndc}
$$
最后进行透视除法（归一化）：
$$
P_{world} = \frac{P_{world\_temp}.xyz}{P_{world\_temp}.w}
$$


#### 3. 确定射线方向

射线的起点 ($Origin$) 通常就是摄像机的世界坐标位置。

射线的方向 ($Direction$) 就是刚才计算出的 $P_{world}$ 减去 摄像机位置，然后归一化。



### 第二步：碰撞检测 (Intersection Test)

#### 1. 粗测阶段 (Broad Phase) - AABB / OBB

**不要**直接拿射线去和几万个三角形做检测，FPS 会掉到个位数。 每个模型（Mesh）应该有一个 **包围盒 (Bounding Box)**。

- 如果射线没有击中包围盒，直接跳过该物体。
- 算法：**Slab Method** (射线与 AABB 的求交算法，非常快)。

#### 2. 精测阶段 (Narrow Phase) - Ray-Triangle

如果击中了包围盒，再遍历该 Mesh 的所有三角形。

- 算法：**Möller–Trumbore 算法**。这是最经典的射线与三角形求交算法，不需要计算平面的法线方程，直接用重心坐标算出交点。

#### 3. 排序

射线可能会穿透多个物体。你需要维护一个列表，记录所有碰撞点，然后按**距离摄像机的远近**排序，最近的那个才是玩家点击的物体。

## 如何实现UDP的可靠传输

KCP

## C++中一个子类继承两个父类，两个父类中有同名虚函数，那么子类中重写虚函数的时候，**重写的是哪个父类的虚函数**

子类会同时重写两个父类的虚函数

```c++
#include <iostream>

class InterfaceA {
public:
    virtual void Update() {
        std::cout << "InterfaceA::Update" << std::endl;
    }
};

class InterfaceB {
public:
    virtual void Update() {
        std::cout << "InterfaceB::Update" << std::endl;
    }
};

class Child : public InterfaceA, public InterfaceB {
public:
    // 这里重写 Update
    // 并没有语法允许你写 override InterfaceA::Update 或 similar
    void Update() override {
        std::cout << "Child::Update (Overrides BOTH)" << std::endl;
    }
};

int main() {
    Child* c = new Child();

    // 1. 直接调用
    c->Update(); 

    // 2. 通过父类 A 指针调用
    InterfaceA* ptrA = c;
    ptrA->Update();

    // 3. 通过父类 B 指针调用
    InterfaceB* ptrB = c;
    ptrB->Update();

    delete c;
    return 0;
}

//Child::Update (Overrides BOTH)
//Child::Update (Overrides BOTH)
//Child::Update (Overrides BOTH)
```

