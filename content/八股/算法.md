# Kadane 算法

解决最长/最短 连续子数组问题，变种是环形子数组和二维矩阵的最大子矩阵和

Kadane 算法的精髓在于遍历数组时，对每一个元素做一个简单的判断：

> **“之前的累加和对我是否有益？”**

- **有益 (之前的和 > 0)：** 如果之前的累加和是正数，那么加上它会让当前的数值变得更大，所以我们**继承**之前的和。
- **无益 (之前的和 $\le$ 0)：** 如果之前的累加和是负数（或0），加上它只会“拖累”当前的数值，所以我们**抛弃**之前的和，从当前元素**重新开始**计算。