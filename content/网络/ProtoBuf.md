# ProtoBuf

ProtoBuf是一种，序列化反序列化的手段

当然XML，Json也是，但是比起那种原模原样的序列化，ProtoBuf采用了一些压缩的技术

## Varint

对于Int32，int64，bool，enum这些，proto使用一种叫做Varint的编码类型。

简单来说，对于proto中的一个字节，只有七个bit的数据位是有效载荷。第一个bit是用来标识，下一个bit是否可以用来作为当前的数字来解释

> 重要：Varint是小端序

例1 ： 比如现在来了一串二进制：1010 1100 0000 0010

这里显然是两个字节

先取出第一个字节：1010 1100。这个字节的第一个bit是1 表示接下来的那个字节还要加入当前这个数字的解析当中，去掉首位的1之后，剩下的是[0]010 1100。Varint是小端序，说明，当前这个0010 1100是低位

因为首位为1，所以接着解析下一个字节：0000 0010。首位是0，因此不需要接着往下看了，这个数字到这里为止了。这里剩下的是 [0]000 0010。

我们把它转化为大端序来可读： 000 0010 << 7 | 010 1100。也就是，高位的左移7位，也即是000 0010 <<7 然后加低位的7位 。合在一起就是：10010 1100，这是300.只用一个字节就表示出了300

例2 ：再比如 127 ： 1000 0001

由于只有7位的载荷，因此127会被转换为：

低七位：000 0001 加上一个1的开头表示还没结束=> [1]000 0001

最高位的1溢出了，高七位：000 0001，加上一个开头的0，表示结束了：[0]000 0001

现在传输的就是（小端序）： 1000 0001 0000 0001

现在解码： 提取 [1]000 0001，剩下七位：000 0001

提取：[0]000 0001 ,剩下七位：000 0001

高位左移7位：1000 0000，和低位取或 ： 1000 0000 | 000 0001 => 1000 0001

完美！

但是这个算法只能解决无符号数

## ZigZag ： 有符号数

因为在有符号数当中，都是用补码表示，负数的最高位一定是（最左侧的）1

按照上面的例2，最高位是1的话，就要一直补，一直补，所以对于64位负数补码来说，都要统一用10个字节：（因为64/7向上取整是10）



ZigZag 编码就是解决这个问题的，他会把有符号数字，统一的映射为无符号数字

| 原始信息    | 编码后     |
| ----------- | ---------- |
| 0           | 0          |
| -1          | 1          |
| 1           | 2          |
| -2          | 3          |
| 2           | 4          |
| -3          | 5          |
| 3           | 6          |
| 2147483647  | 4294967294 |
| -2147483648 | 4294967295 |

接受之后再转换为有符号数字就可以了

## Float

对于float这种浮点数来说。对于小端序Proto就是直接memoryCopy的

## 字段名和字段类型（Tag）

一个问题

对于int i =100来说，我们需要明确：

接下来这个变量叫做：i。i的类型是int。i的值是100

proto采用keyValue的方法。value是值，也就是上面说的Varint和Float。Key则是字段名和字段类型合在一起。同时字段名也不需要真的穿名字，只需要客户端服务器用同一份Proto导出的代码，里面对变量名统一编号，就能用字段编号表示字段名了。而类型，proto只有6种类型，因此也只需要3位就可以表示，这个key，叫做Tag

```
Tag = (字段名编号 << 3) | 字段类型
```

```protobuf
message Test{ 
	int id = 1, //注意：这个1和下面的2就是字段名编号，它要求messgae里唯一
	string name = 2,
}
```



字段类型就是Wire Type

| **Wire Type ID** | **名称 (Name)**      | **数据结构 (Structure)** | **对应的 Proto 语言类型 (Data Types)**                       |
| ---------------- | -------------------- | ------------------------ | ------------------------------------------------------------ |
| **0**            | **Varint**           | 变长编码                 | `int32`, `int64`, `uint32`, `uint64`, `sint32`, `sint64`, `bool`, `enum` |
| **1**            | **64-bit**           | 固定 8 字节              | `fixed64`, `sfixed64`, `double`                              |
| **2**            | **Length-delimited** | 长度前缀 + 数据          | `string`, `bytes`, `embedded messages` (嵌套消息), `packed repeated fields` |
| **3**            | **Start Group**      | (已弃用)                 | Groups (Deprecated)                                          |
| **4**            | **End Group**        | (已弃用)                 | Groups (Deprecated)                                          |
| **5**            | **32-bit**           | 固定 4 字节              | `fixed32`, `sfixed32`, `float`                               |

![fb58fa774a9149847a97b6b512ad8167](./assets/fb58fa774a9149847a97b6b512ad8167.jpg)

比如server收到了：一个kV：

key ： 0000 1000

后三位为000，解释为Varint，前面是：0000 1，也就是1对应的字段名编号

### 嵌套类型

对于嵌套类型：

```protobuf
message SubMsg{
	optional int32 id =1,
}
```

也遵循kv的逻辑，只是内部的sub字段也由kv表示：

![cff2dd5b07e080d7d916612d3f82c351](./assets/cff2dd5b07e080d7d916612d3f82c351.jpg)

## 字符串类型：

对于字符串，Proto采用的是长度前缀的编码：也就是Tag - Length - Value

Tag上面说过了，Length是一个Varint编码的数字，表示后面的字符串有多少个字节，Value就是真是的字节内容，用的是UTF-8



## 限制

### Varint 的极限与坑

Varint 的设计是用 **空间换时间/灵活性**，但在处理大数时，它其实是 **亏本** 的。

#### A. 物理极限：10 字节 (The 10-Byte Wall)

Varint 编码规则是每个字节只有 7 位用于存储数据（1位用于标记）。

ProtoBuf 支持的最大整数类型是 64 位（uint64, int64）。

我们要存下 64 个 bit，需要多少个 7-bit 的组？
$$
\lceil 64 / 7 \rceil = 10
$$


- **结论：** 一个 Varint **最多占用 10 个字节**。
- **硬限制：** 绝大多数标准 ProtoBuf 解析器（C++, Java, Go 等）在读取 Varint 时，如果读到第 11 个字节仍然发现 MSB（最高位）是 1，会直接抛出 `Malformed Protocol Buffer` 异常。它不会允许无限长的 Varint 存在。

#### B. 效率极限：何时亏本？ (Varint vs Fixed)

Varint 并不总是省空间的。

- **Fixed64:** 永远固定 8 字节。
- **Varint:** 随着数值变大，长度从 1 字节涨到 10 字节。

分水岭在哪里？

当数值大于 $2^{56}$ 时（即需要 8 个 7-bit 组以上,其实就是最后的8x7），Varint 需要 9 或 10 个字节。

此时 Varint 比 Fixed64（8字节）还要大！

> **场景提示：** 如果你在存 **随机的大整数**（如哈希值、随机 ID、加密数据的 Key），千万别用 Varint（即别用 `uint64`），请直接使用 `fixed64`。



## Reference：

https://zhuanlan.zhihu.com/p/633656133?share_code=1kXmeRycLZHLN&utm_psn=1981177878906429976