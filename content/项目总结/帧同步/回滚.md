# 回滚

## 类内的对象

直接覆盖

## 类之间的引用

<img src="assets/ebb055d8b9b9e793a574cc78f450b0e7.jpg" alt="ebb055d8b9b9e793a574cc78f450b0e7" style="zoom:50%;" />

比如这个例子，PlayerEntity同时在PlayerManager和EntityManager里被管理

如果正常的回滚，就没问题

但是如果假设PlayerEntity在一帧中被摧毁了，结果过了几帧发现搞错了，那么回滚后要重新Init一个Player对象出来，然后执行重新绑定业务层引用的逻辑

这里重新绑定引用指的是：PlayerEntity内部要去重新绑定所有持有它引用的外部对象，对于它的引用。根据什么来查找引用呢？还是根据统一的ID系统。

因此我们回滚设计五个接口：

OnSpawn，Restore，BackUp和OnRevive，OnDespawn

其中，OnSpawn负责创建物体时候的一些绑定操作，Restore和BackUp负责内部数据的序列化和回滚驱动

OnRevive负责回滚销毁物体的重建，OnDespawn负责清理（比如业务层的引用，还有物理层的反注册）

> 为什么要拆分OnSpawn和OnRevive，保留它们的**分离**，但提取**公共逻辑**比较好，
>
> 以及为什么要拆分OnSpawn和Restore？因为不需要一直重新注册，正常的回滚如果不涉及到回滚前后物体销毁的问题其实时不需要重新注册的，但是i回滚本身是经常发生的，合在一起会有性能问题

```mermaid
graph TD
    %% 节点定义
    Pool[(对象池 Pool)]
    
    subgraph NormalFlow [正常游戏流程]
        Spawn(Spawn 生成)
        Init(Init 初始化)
        Update(DoUpdate 逻辑循环)
        Despawn(Despawn 销毁/回收)
    end
    
    subgraph RollbackFlow [回滚补帧流程]
        RestoreCheck{快照比对?}
        Revive(OnRevive 复活)
        RollbackDespawn(预测错误销毁)
    end

    %% 连线关系
    Pool -->|复用| Spawn
    Spawn -->|分配新ID| Init
    Init -->|注册引用| Update
    
    Update -->|被击杀/销毁| Despawn
    Despawn -->|注销引用| Pool

    %% 回滚逻辑
    Update -.->|保存快照| RestoreCheck
    RestoreCheck -->|当前有但快照无| RollbackDespawn
    RollbackDespawn -->|强制回收| Pool
    
    RestoreCheck -->|快照有但当前无| Revive
    Pool -->|复用| Revive
    
    Revive -->|1.恢复数据| Revive
    Revive -->|2.重新绑定引用| Update
    
    style Revive fill:#f96,stroke:#333,stroke-width:2px,color:white
    style Init fill:#69f,stroke:#333,stroke-width:2px,color:white
```



```mermaid
sequenceDiagram
    autonumber
    participant RB as RollbackManager
    participant EM as EntityManager
    participant P as PlayerEntity (新实例)
    participant PM as PlayerManager (全局单例)
    participant CM as CollisionManager (物理系统)

    Note over RB, EM: 检测到 Tick 100 时玩家存在，但当前场景里没有

    RB->>EM: Restore(reader)
    
    Note right of EM: 1. 从对象池取出空壳对象
    EM->>P: 实例化 / Pool.Get()
    
    Note right of EM: 2. 恢复基础数据 (此时它还是个"黑户")
    EM->>P: Restore(reader)
    P->>P: 恢复 PlayerIndex=1, EntityId=500, Pos=(10,0,10)...

    Note right of EM: 3. 执行"复活"手术 (关键步骤)
    EM->>P: OnRevive()
    activate P
    
    Note over P, PM: 步骤 A: 修复业务层引用 (防腐烂)
    P->>PM: 查 PlayerIndex=1 的记录
    alt 字典里有旧引用
        P->>PM: PlayerId2EntitiesDic[1] = this (强制覆盖!)
    else 字典为空
        P->>PM: Add(1, this) (重新添加)
    end
    Note right of PM: 现在 PlayerManager 里的引用<br/>指向了当前这个活着的 P
    
    Note over P, CM: 步骤 B: 修复物理层引用
    P->>P: bodyCollider.ownerId = 500
    P->>CM: Register(bodyCollider, this)
    Note right of CM: 物理引擎重新接管该物体
    
    Note over P: 步骤 C: 修复表现层
    P->>P: PlayerView.Bind(this)
    
    deactivate P

    Note over RB, P: 回滚结束，下一帧逻辑 Update 开始
```

