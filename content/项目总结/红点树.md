# RedDot

红点数本质上是一套数据存储系统。它自己只负责维护红点前缀树上每个节点的状态。

而对于UI系统来说，需要它自己在创建的时候主动的拿自己的路径去更新。

本地存储已读掩码，服务器只存全量，更新的时候求差大于零再显示

父节点的红点值都是由子节点的红点值计算得到的

```lua
-- RedDotMgr.lua
-- 这是一个单例模块
local RedDotMgr = {}

--=============================================================================
-- 1. 基础设施：模拟本地存储与工具
--=============================================================================
local LocalStorage = {
    -- 模拟 PlayerPrefs
    SetString = function(self, key, val) 
        -- UnityEngine.PlayerPrefs.SetString(key, val)
        print("[Disk] Save: " .. key .. " = " .. tostring(val)) 
    end,
    GetString = function(self, key, default) 
        -- return UnityEngine.PlayerPrefs.GetString(key, default)
        return default 
    end
}

--=============================================================================
-- 2. 节点类定义 (Node)
--=============================================================================
local Node = {}
Node.__index = Node

function Node.New(name, parent, path)
    local t = {
        name = name,
        parent = parent,      -- 父节点引用
        path = path,          -- 全路径 "Main.Mail"
        children = {},        -- 子节点列表
        
        -- 数据部分
        serverCount = 0,      -- 服务器原始数据
        localMask = 0,        -- 本地消除的掩码
        displayValue = 0,     -- 最终展示给 UI 的值 (缓存)
        
        -- 脏标记
        isDirty = false,      -- 是否需要重算
        
        -- UI 回调列表
        listeners = {}        
    }
    setmetatable(t, Node)
    return t
end




--=============================================================================
-- 3. 红点管理器核心
--=============================================================================

Root
 ├── Main (Sum = 5)
 │    ├── Role (Sum = 1)
 │    │    └── Attribute (Count = 1)
 │    ├── Bag (Sum = 2)
 │    │    ├── Weapon (Count = 2)
 │    │    └── Armor (Count = 0)
 │    └── Social (Sum = 2)
 │         ├── Friend (Sum = 2)
 │         │    └── Apply (Count = 2)
 │         └── Guild (Sum = 0)
 └── Chat (独立于主界面的红点，如果需要的话)

local configList = {
    -- 格式：根节点.一级界面.二级界面.具体功能
    
    -- 【主界面 - 角色头像】
    "Main.Role.Attribute",      -- 属性加点
    "Main.Role.Title",          -- 称号获得
    
    -- 【主界面 - 背包】
    "Main.Bag.Weapon",          -- 新武器
    "Main.Bag.Armor",           -- 新防具
    "Main.Bag.Consumable",      -- 新消耗品
    
    -- 【主界面 - 社交】
    "Main.Social.Friend.Apply", -- 好友申请
    "Main.Social.Chat.Private", -- 私聊消息
    "Main.Social.Guild.Apply",  -- 公会审批
    
    -- 【主界面 - 福利】
    "Main.Welfare.DailySign",   -- 每日签到
    "Main.Welfare.LevelReward", -- 等级奖励
}

return configList


RedDotMgr.root = nil
RedDotMgr.paths = {}      -- 路径索引: "Main.Mail" -> Node Flat Map, O1时间快速查找节点
RedDotMgr.dirtySet = {}   -- 脏节点集合: { [node] = true }

-- 初始化树结构
function RedDotMgr:Init(configList)
    self.root = Node.New("Root", nil, "Root") -- Node.New(name, parent, path)
    self.paths = {}
    self.dirtySet = {}
    
    for _, path in ipairs(configList) do
        -- path = "Main.Mail.System"
        local current = self.root 
        local names = self:SplitString(path, ".") -- names = {"Main", "Mail", "System"}
        local currPath = ""
        
        for i, name in ipairs(names) do
            -- i == 1 currPath = Main
            -- i == 2 currPath = Main.Mail
            currPath = (i == 1) and name or (currPath .. "." .. name)
            
            if not current.children[name] then
                local newNode = Node.New(name, current, currPath)
                current.children[name] = newNode
                self.paths[currPath] = newNode
                
                -- 初始化时读取本地存储
                local savedMask = tonumber(LocalStorage:GetString("RD_" .. currPath, "0"))
                newNode.localMask = savedMask or 0
            end
            current = current.children[name]
        end
    end
    print("[RedDot] Init Complete.")
end

--=============================================================================
-- 4. 数据输入接口 (只标记，不计算)
--=============================================================================

-- 服务器数据更新
function RedDotMgr:UpdateServerData(path, count)
    -- 使用新函数
    local node = self:GetOrCreateNode(path) 
    
    if not node then 
        print("Error: Invalid path " .. path)
        return 
    end

    if node.serverCount ~= count then
        node.serverCount = count
        self:MarkDirty(node)
    end
end


-- 辅助函数：动态获取或创建节点
function RedDotMgr:GetOrCreateNode(path)
    if self.paths[path] then return self.paths[path] end

    local parentPath, nodeName = self:SplitLast(path)
    local parentNode = self.paths[parentPath]
    
    if parentNode then
        -- 1. 检查父节点是否已经加载过“已读列表”
        if parentNode.dynamicMasks == nil then
            -- 从本地加载父节点的存档: "RD_Main.Mail.List" -> "1001,1002,1005"
            local str = LocalStorage:GetString("RD_" .. parentPath, "")
            parentNode.dynamicMasks = self:ParseMaskList(str)
        end
        
        -- 2. 创建新节点
        local newNode = Node.New(nodeName, parentNode, path, self.Type.Normal)
        
        -- 3. 【关键】直接从父节点的缓存里查，看自己是不是已读
        -- nodeName 就是 ID (比如 "1001")
        if parentNode.dynamicMasks[nodeName] then
            newNode.localMask = 1 -- 恢复已读状态
        else
            newNode.localMask = 0
        end

        parentNode.children[nodeName] = newNode
        self.paths[path] = newNode
        
        return newNode
    end
    return nil
end

-- RedDotMgr.lua 增加或修改部分

-- 辅助：字符串分割为 Table (用于解析 "1001,1002")
function RedDotMgr:ParseMaskList(str)
    local map = {}
    if not str or str == "" then return map end
    for id in string.gmatch(str, "([^,]+)") do
        map[id] = 1 -- 标记为已读
    end
    return map
end

-- 辅助：Table 转字符串 (用于保存)
function RedDotMgr:SerializeMaskList(map)
    local list = {}
    for id, _ in pairs(map) do
        table.insert(list, id)
    end
    return table.concat(list, ",")
end


-- 客户端交互：标记已读
function RedDotMgr:MarkRead(path)
    local node = self.paths[path]
    if not node then return end

    -- 逻辑：把 mask 提升到和 serverCount 一样高
    if node.localMask ~= node.serverCount then
        node.localMask = node.serverCount
        
        -- 保存到本地
        LocalStorage:SetString("RD_" .. path, tostring(node.localMask))
        
        -- 标记脏
        self:MarkDirty(node)
    end
end

-- 内部：将节点加入脏列表
function RedDotMgr:MarkDirty(node)
    if not node.isDirty then
        node.isDirty = true
        self.dirtySet[node] = true
    end
end

--=============================================================================
-- 5. 核心驱动：延迟更新循环 (The Update Loop)
--=============================================================================

-- 这个函数应该由 C# 的 Update 或 LateUpdate 每帧调用一次
function RedDotMgr:OnUpdate()
    -- 性能优化：如果没有脏节点，直接返回，零消耗
    if next(self.dirtySet) == nil then return end

    local loopCount = 0
    local maxLoops = 10 -- 防止死循环的安全锁

    -- 循环处理：因为子节点更新可能会导致父节点变脏，
    -- 我们需要不断把新产生的脏节点处理掉，直到没有任何节点是脏的。
    -- 正常树结构，这里循环次数 = 树的层级深度 (通常 < 5)
    while next(self.dirtySet) and loopCount < maxLoops do
        
        -- 1. 取出当前这一批脏节点
        local currentBatch = self.dirtySet
        
        -- 2. 立即清空主列表 (准备接收下一轮产生的父节点)
        self.dirtySet = {} 

        -- 3. 遍历处理
        for node, _ in pairs(currentBatch) do
            node.isDirty = false -- 清除标记
            self:ProcessNode(node)
        end

        loopCount = loopCount + 1
    end
end

-- 处理单个节点：计算 -> 通知 -> 污染父节点
function RedDotMgr:ProcessNode(node)
    local oldVal = node.displayValue
    
    -- --- [计算公式] ---
    -- 1. 自身的净值 (Max(0, Server - Local))
    local selfVal = math.max(0, node.serverCount - node.localMask)
    
    -- 2. 加上所有子节点的值
    local childrenVal = 0
    for _, child in pairs(node.children) do
        childrenVal = childrenVal + child.displayValue
    end
    
    local newVal = selfVal + childrenVal
    -- ------------------

    -- 只有最终结果变了，才触发后续逻辑
    if oldVal ~= newVal then
        node.displayValue = newVal
        
        -- A. 通知 UI
        self:NotifyUI(node)
        
        -- B. 关键：子节点变了，父节点的数据必定也是错的了
        -- 所以把父节点加入脏列表，下一轮循环处理
        if node.parent and node.parent.name ~= "Root" then
            self:MarkDirty(node.parent)
        end
    end
end

--=============================================================================
-- 6. UI 绑定与辅助
--=============================================================================

function RedDotMgr:Bind(path, callback)
    local node = self.paths[path]
    if not node then return end
    
    table.insert(node.listeners, callback)
    -- 绑定时立即执行一次
    callback(node.displayValue)
end

function RedDotMgr:NotifyUI(node)
    for _, cb in ipairs(node.listeners) do
        cb(node.displayValue)
    end
    -- debug log
    -- print(string.format(">> UI Update: [%s] = %d", node.path, node.displayValue))
end

function RedDotMgr:SplitString(input, delimiter)
    local result = {}
    for match in (input .. delimiter):gmatch("(.-)" .. delimiter) do
        table.insert(result, match)
    end
    return result
end

return RedDotMgr
```



## 和服务器的同步以及本地的存储

红点树是一个树结构的，它可以直接用前缀树来做，但是前缀树的问题是会涉及到节点查找的时候，字符串的拼接和剪切问题，Lua这边拼接的时候会有很多临时的字符串，这些字符串会有GC，因此我们存储树结构的同时，用一个 Flat Map，直接存储Path到Node的映射。这样就不需要切剪字符串去做前缀树的查找了





## Dirty优化

我们的红点树是基于延迟更新的，这是适用于可能存在的一帧大量红点信息的场景。

会引起Dirty的行为有：UI层的红点消除行为，服务器推送的红点信息

Update驱动每一帧结尾的时候检查所有的脏数据。

当发现一个节点的数据为脏的时候，我们应该重新计算当前节点的服务器值和本地Mask,以及所有的子节点的newVal，为新的DisPlayValue。然后污染父节点（注意这时候没有直接递归），被污染的父节点将在下一个伦茨（而不是下一帧）被处理。这一步是为了防止在一伦茨中多次修改子节点导致的父节点被反复重新计算

```lua
-- 这个函数应该由 C# 的 Update 或 LateUpdate 每帧调用一次
function RedDotMgr:OnUpdate()
    -- 性能优化：如果没有脏节点，直接返回，零消耗
    if next(self.dirtySet) == nil then return end

    local loopCount = 0
    local maxLoops = 10 -- 防止死循环的安全锁

    -- 循环处理：因为子节点更新可能会导致父节点变脏，
    -- 我们需要不断把新产生的脏节点处理掉，直到没有任何节点是脏的。
    -- 正常树结构，这里循环次数 = 树的层级深度 (通常 < 5)
    while next(self.dirtySet) and loopCount < maxLoops do
        
        -- 1. 取出当前这一批脏节点
        local currentBatch = self.dirtySet
        
        -- 2. 立即清空主列表 (准备接收下一轮产生的父节点)
        self.dirtySet = {} 

        -- 3. 遍历处理
        for node, _ in pairs(currentBatch) do
            node.isDirty = false -- 清除标记
            self:ProcessNode(node)
        end

        loopCount = loopCount + 1
    end
end

-- 处理单个节点：计算 -> 通知 -> 污染父节点
function RedDotMgr:ProcessNode(node)
    local oldVal = node.displayValue
    
    -- --- [计算公式] ---
    -- 1. 自身的净值 (Max(0, Server - Local))
    local selfVal = math.max(0, node.serverCount - node.localMask)
    
    -- 2. 加上所有子节点的值
    local childrenVal = 0
    for _, child in pairs(node.children) do
        childrenVal = childrenVal + child.displayValue
    end
    
    local newVal = selfVal + childrenVal
    -- ------------------

    -- 只有最终结果变了，才触发后续逻辑
    if oldVal ~= newVal then
        node.displayValue = newVal
        
        -- A. 通知 UI
        self:NotifyUI(node)
        
        -- B. 关键：子节点变了，父节点的数据必定也是错的了
        -- 所以把父节点加入脏列表，下一轮循环处理
        if node.parent and node.parent.name ~= "Root" then
            self:MarkDirty(node.parent)
        end
    end
end
```

<span style="color:#66FF66;">（想一下这个更新逻辑，是不是脏标记的过程一定是从最末端的子节点触发，然后父节点其实都是被传染的脏标记，这样可以保证父节点总能处理最新的，相当于展开了递归过程）</span>

> 为什么要等到下一帧更新呢，因为如果你在处理子节点的时候，立刻让父节点加入当前的计算队列，父节点可能会读到其他“还没来得及更新的子节点”的旧数据





## 静态节点和动态节点

这样一个场景：

我们的结构是：Main.Mail.List

然后有很多邮件，那么问题来了：这些邮件咋处理呢？以及他们如何本地序列化

我们采用的方法是：静态构建根节点，然后动态构建这些动态节点

静态节点是这样的：比如我们的UI固定，固定有一个技能按钮，一个什么装备按钮，那么这个位置就应该作为静态节点来处理。

但是还有很多比如滚动列表里会有很多动态的节点，那么他们应该如何存储？

对于动态节点，我们的红点系统初始化的时候不需要去构建他，我们只构建静态节点。

在服务器下发动态红点数据的时候，我们先查找当前的红点树中，这个节点父节点，看它是否加载过序列化后的动态列表，如果加载过，那么就去和那个对比

怎么本地持久化存储呢？Main.Mail.List_1001_1002_1003 类似这样，直接给父节点List后面跟上一堆的列表就可以了，这样就不需要搞一个类似于

Main.Mail.List.1001

Main.Mail.List.1002这样好多节点，会导致序列化的文件暴增。上面这种存储还有个好处就是如果要重置这棵树，直接删掉Main.Mail.List后面跟着的内容就可以了



## 突然解锁

考虑到一个情况是，玩家升到10级，然后解锁一个新的功能，这个功能解锁了新的红点（比如解锁工会，然后工会有三封邮件）

我们现在也是支持的，第一是就算是解锁，也是正常流程的，那么它也应该提前构建好。第二，当我们发现父节点存当前节点不存在的时候，也会更新红点树



## 离线更新

场景：

1. 玩家 A 上次下线时，服务器有 10 封邮件，玩家点到了 **已读 10**（`LocalMask = 10`）。
2. **玩家 A 离线**。
3. 服务器给玩家 A 发了 5 封新邮件（现在总数是 15）。
4. **玩家 A 重新登录**。

此时，本地只记录了“我读过 10 封”，服务器只知道“你现在有 15 封”。

解决方法是：我们持久化的时候，本地要持久化一个时间戳，登录的时候把这个时间戳一起发给服务器，服务器把在此之后的红点数据更新下来，只做增量更新





## 持久化时机

我也没有太好的想法：因为玩家会杀进程

所以现在是用了三级缓存的方法：

### 第一部分：本地持久化的时机 (Save Timing)

正如你所说，指望 `OnApplicationQuit` 是不靠谱的（手机上直接杀后台、没电关机都不会触发它）。

而在每一次点击红点（`MarkRead`）时立即写磁盘（IO 操作）又太消耗性能，会造成瞬间卡顿。

**最佳实践是采用“三级缓冲策略”：**

#### 1. 必选：`OnApplicationPause(true)` 

这是手机游戏最黄金的存盘时机。当玩家按下 Home 键、切换应用、接电话时，Unity 会触发这个回调。

- **可靠性**：极高。iOS 和 Android 杀进程前几乎都会先进入 Pause 状态。
- **逻辑**：在这里调用 `RedDotMgr:SaveAll()`。

#### 2. 辅助：关键 UI 关闭时

当玩家**关闭一个可能产生红点消除的大界面**（如关闭邮件界面、关闭背包界面）时，触发一次保存。

- **理由**：玩家通常在这些界面里狂点一通，关掉界面意味着一段交互的结束。
- **逻辑**：在 `MailPanel:OnClose()` 里调用 `RedDotMgr:SaveAll()`。

#### 3. 兜底：脏标记 + 定时器 (Debounce/Throttle)

如果玩家一直在游戏里不切后台，也不关界面，我们不能一直不存。

- **机制**：`MarkRead` 时不存盘，只设 `isDirty = true`。
- **定时**：开启一个 5~10 秒的计时器，如果 `isDirty` 为 true，则写入一次磁盘。